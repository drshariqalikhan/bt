<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>QualityStock Screener</title>
    
    <meta name="theme-color" content="#1a1d21">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="QualityStock">

    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@1.0.4/css/bulma.min.css">

    <style>
        :root { --dark-bg-1: #1a1d21; --dark-bg-2: #272a2e; --dark-border: #444; --light-text: #f0f0f0; --dim-text: #a0a0a0; }
        html { background-color: var(--dark-bg-1); height: 100svh; }
        body { background-color: var(--dark-bg-1); color: var(--light-text); display: flex; flex-direction: column; height: 100%; margin: 0; }
        .navbar { background-color: var(--dark-bg-2); border-bottom: 1px solid var(--dark-border); }
        .navbar-item, .navbar-link { color: var(--light-text); cursor: pointer; }
        .navbar-burger span { background-color: var(--light-text); }
        .input, .select select { background-color: var(--dark-bg-1); border-color: var(--dark-border); color: var(--light-text); }
        .input::placeholder { color: var(--dim-text); }
        .label { color: var(--light-text); }

        .page { display: flex; flex-direction: column; height: 100%; width: 100%; }
        #settingsPage { display: none; }
        .page-nav { padding-top: env(safe-area-inset-top); flex-shrink: 0; }
        .page-content { flex-grow: 1; overflow-y: auto; -webkit-overflow-scrolling: touch; padding-bottom: env(safe-area-inset-bottom); }

        #appContainer { display: flex; flex-direction: column; gap: 1rem; height: 100%; padding: 1rem; }
        .chart-wrapper { background-color: var(--dark-bg-2); border-radius: 6px; flex: 1; position: relative; min-height: 200px; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        .settings-container { padding: 1.5rem; }
        .settings-field { max-width: 400px; margin-bottom: 1.5rem; }
    </style>
</head>
<body>

    <!-- PAGE 1: MAIN PAGE (CHARTS) -->
    <div id="mainPage" class="page">
        <nav class="navbar page-nav" role="navigation" aria-label="main navigation">
            <div class="navbar-brand">
                <a class="navbar-item has-text-weight-bold">Quality Screen</a>
                <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false" data-target="navbarBasicMenu"><span></span><span></span><span></span></a>
            </div>
            <div id="navbarBasicMenu" class="navbar-menu">
                <div class="navbar-start">
                    <div class="navbar-item">
                        <div class="field is-grouped">
                            <p class="control is-expanded"><input class="input" type="text" id="tickerInput" value="MSFT.US" placeholder="e.g., AAPL.US"></p>
                            <p class="control"><button id="fetchButton" class="button is-info">Fetch</button></p>
                        </div>
                    </div>
                    <a class="navbar-item" id="goToSettingsButton">Settings</a>
                </div>
            </div>
        </nav>

        <main class="page-content">
            <div id="appContainer">
                <div id="priceChartWrapper" class="chart-wrapper"><canvas id="priceChart"></canvas></div>
                <div id="macdChartWrapper" class="chart-wrapper"><canvas id="macdChart"></canvas></div>
                <div id="statusMessage" class="has-text-centered" role="status"></div>
            </div>
        </main>
    </div>

    <!-- PAGE 2: SETTINGS PAGE -->
    <div id="settingsPage" class="page">
        <nav class="navbar page-nav">
            <div class="navbar-brand"><a class="navbar-item" id="backButton">< Back</a></div>
            <div class="navbar-menu is-active"><div class="navbar-start"><div class="navbar-item has-text-weight-bold">Settings</div></div></div>
        </nav>
        <main class="page-content">
            <div class="settings-container">
                <h2 class="title is-4 has-text-light">Chart Display</h2>
                <div class="field settings-field">
                    <label class="label" for="timePeriodSelector">Default Time Period</label>
                    <div class="control">
                        <div class="select is-fullwidth">
                            <select id="timePeriodSelector">
                                <option value="all">All Time</option>
                                <option value="10yr">10 Years</option>
                                <option value="5yr" selected>5 Years</option>
                                <option value="1yr">1 Year</option>
                            </select>
                        </div>
                    </div>
                </div>
                <hr style="background-color: var(--dark-border);">
                <h2 class="title is-4 has-text-light">App Data</h2>
                <div class="field">
                    <div class="control"><button class="button is-danger" id="deleteDataButton">Clear All Saved Data</button></div>
                    <p class="help has-text-grey">This will clear the last viewed ticker.</p>
                </div>
            </div>
        </main>
    </div>

    <script>
        (function() {
            // --- SECTION 1: CONSTANTS AND STATE ---
            const CORS_PROXY = "https://api.allorigins.win/raw?url=";
            const LAST_TICKER_KEY = 'qualitystock_lastTicker';
            let allDates = [], allPrices = [];

            // --- SECTION 2: DOM ELEMENT REFERENCES ---
            let mainPage, settingsPage, goToSettingsButton, backButton,
                tickerInput, fetchButton, timePeriodSelector,
                priceCanvas, priceCtx, macdCanvas, macdCtx, statusMessage,
                deleteDataButton;

            // --- SECTION 3: PRIMARY EVENT LISTENER ---
            document.addEventListener('DOMContentLoaded', () => {
                // Assign references
                mainPage = document.getElementById('mainPage');
                settingsPage = document.getElementById('settingsPage');
                goToSettingsButton = document.getElementById('goToSettingsButton');
                backButton = document.getElementById('backButton');
                tickerInput = document.getElementById('tickerInput');
                fetchButton = document.getElementById('fetchButton');
                timePeriodSelector = document.getElementById('timePeriodSelector');
                priceCanvas = document.getElementById('priceChart');
                priceCtx = priceCanvas.getContext('2d');
                macdCanvas = document.getElementById('macdChart');
                macdCtx = macdCanvas.getContext('2d');
                statusMessage = document.getElementById('statusMessage');
                deleteDataButton = document.getElementById('deleteDataButton');

                // Page Navigation Listeners
                goToSettingsButton.addEventListener('click', () => { mainPage.style.display = 'none'; settingsPage.style.display = 'flex'; });
                backButton.addEventListener('click', () => { mainPage.style.display = 'flex'; settingsPage.style.display = 'none'; });
                
                // Burger Menu Listener
                const burger = document.querySelector('.navbar-burger');
                const menu = document.getElementById(burger.dataset.target);
                burger.addEventListener('click', () => { burger.classList.toggle('is-active'); menu.classList.toggle('is-active'); });
                
                // Main Functionality Listeners
                fetchButton.addEventListener('click', fetchData);
                tickerInput.addEventListener('keypress', e => { if (e.key === 'Enter') fetchData(); });
                timePeriodSelector.addEventListener('change', processAndDraw);
                deleteDataButton.addEventListener('click', () => {
                    if (confirm("Are you sure? This will clear the last saved ticker.")) {
                        localStorage.removeItem(LAST_TICKER_KEY);
                        alert("Cleared saved data.");
                    }
                });

                // --- App Initialization ---
                const lastTicker = localStorage.getItem(LAST_TICKER_KEY);
                if (lastTicker) { tickerInput.value = lastTicker; }
                fetchData();
            });

            // --- SECTION 4: CORE LOGIC (DATA FETCHING & PROCESSING) ---
            async function fetchData() {
                const ticker = tickerInput.value.trim().toUpperCase();
                if (!ticker) { statusMessage.textContent = "Please enter a ticker symbol."; return; }
                
                statusMessage.textContent = `Fetching data for ${ticker}...`;
                clearCharts();

                try {
                    const stooqUrl = `https://stooq.com/q/d/l/?s=${ticker}&i=w&c=1`;
                    const proxyUrl = `${CORS_PROXY}${encodeURIComponent(stooqUrl)}`;
                    const response = await fetch(proxyUrl);
                    if (!response.ok) throw new Error(`Network error: ${response.statusText}`);
                    
                    const rawData = await response.text();
                    if (rawData.trim().startsWith('<') || !rawData.toUpperCase().includes('DATE')) {
                        throw new Error('Invalid data format or ticker not found.');
                    }

                    const lines = rawData.trim().split('\n');
                    const headerLine = lines.shift();
                    // --- FIX: Robustly determine the delimiter ---
                    const delimiter = headerLine.includes(';') ? ';' : ',';
                    const headers = headerLine.split(delimiter).map(h => h.trim().toUpperCase());
                    const dateIndex = headers.indexOf('DATE');
                    const closeIndex = headers.indexOf('CLOSE');

                    if (dateIndex === -1 || closeIndex === -1) throw new Error('Could not find "DATE" or "CLOSE" columns.');

                    allDates = [];
                    allPrices = [];
                    lines.forEach(line => {
                        const columns = line.split(delimiter);
                        if (columns.length > Math.max(dateIndex, closeIndex)) {
                            const dateStr = columns[dateIndex];
                            const closePrice = parseFloat(columns[closeIndex]);
                            if (dateStr && !isNaN(closePrice)) {
                                allDates.push(dateStr);
                                allPrices.push(closePrice);
                            }
                        }
                    });

                    if (allPrices.length === 0) throw new Error("No valid price data rows found.");
                    
                    localStorage.setItem(LAST_TICKER_KEY, ticker);
                    statusMessage.textContent = `Displaying ${ticker}`;
                    processAndDraw();

                } catch (error) {
                    statusMessage.textContent = `Error: ${error.message}`;
                    console.error("Fetch error:", error);
                }
            }
            
            function processAndDraw() {
                if (allPrices.length === 0) return;

                const fastPeriod = 10;
                const slowPeriod = 20;
                const full = {
                    fastEma: calculateEMA(allPrices, fastPeriod),
                    slowEma: calculateEMA(allPrices, slowPeriod),
                    ...calculateMACD(allPrices)
                };

                const startIndex = getFilterStartIndex();
                const dates = allDates.slice(startIndex);
                const prices = allPrices.slice(startIndex);
                const sliced = {
                    fastEma: full.fastEma.slice(startIndex),
                    slowEma: full.slowEma.slice(startIndex),
                    macdLine: full.macdLine.slice(startIndex),
                    signalLine: full.signalLine.slice(startIndex),
                    histogram: full.histogram.slice(startIndex)
                };

                if (prices.length === 0) {
                    clearCharts();
                    statusMessage.textContent = "No data available for the selected time period.";
                    return;
                }

                drawPriceChart(dates, prices, sliced, fastPeriod, slowPeriod);
                drawMacdChart(dates, prices, sliced);
            }

            // --- SECTION 5: CALCULATION HELPERS ---
            function getFilterStartIndex() {
                const period = timePeriodSelector.value;
                const totalPoints = allDates.length;
                const weeksInYear = 52;
                if (period === 'all') return 0;
                if (period === '10yr') return Math.max(0, totalPoints - (10 * weeksInYear));
                if (period === '5yr') return Math.max(0, totalPoints - (5 * weeksInYear));
                if (period === '1yr') return Math.max(0, totalPoints - (1 * weeksInYear));
                return 0;
            }

            function calculateEMA(data, period) {
                if (!data || data.length < period) return new Array(data.length).fill(null);
                const k = 2 / (period + 1);
                const ema = new Array(data.length).fill(null);
                let sum = 0;
                for (let i = 0; i < period; i++) sum += data[i];
                ema[period - 1] = sum / period;
                for (let i = period; i < data.length; i++) {
                    if (ema[i-1] !== null) ema[i] = (data[i] * k) + (ema[i - 1] * (1 - k));
                }
                return ema;
            }

            function calculateMACD(data, p12=12, p26=26, pSignal=9) {
                const ema12 = calculateEMA(data, p12);
                const ema26 = calculateEMA(data, p26);
                const macdLine = ema26.map((v, i) => v !== null && ema12[i] !== null ? ema12[i] - v : null);
                const signalLine = calculateEMA(macdLine, pSignal);
                const histogram = signalLine.map((v, i) => v !== null && macdLine[i] !== null ? macdLine[i] - v : null);
                return { macdLine, signalLine, histogram };
            }

            // --- SECTION 6: CHARTING FUNCTIONS ---
            function clearCharts() {
                priceCtx.clearRect(0, 0, priceCanvas.width, priceCanvas.height);
                macdCtx.clearRect(0, 0, macdCanvas.width, macdCanvas.height);
            }

            const drawLine = (ctx, data, mapX, mapY, color, lineWidth = 1.5) => {
                ctx.beginPath();
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = color;
                let first = true;
                data.forEach((val, i) => {
                    if (val !== null) {
                        const x = mapX(i);
                        const y = mapY(val);
                        if (first) { ctx.moveTo(x, y); first = false; } else { ctx.lineTo(x, y); }
                    }
                });
                ctx.stroke();
            };
            
            function drawPriceChart(dates, prices, slicedData, fastPeriod, slowPeriod) {
                const container = priceCanvas.parentElement;
                const w = container.clientWidth, h = container.clientHeight;
                if (w <= 0 || h <= 0) return;

                priceCanvas.width = w * devicePixelRatio;
                priceCanvas.height = h * devicePixelRatio;
                priceCtx.scale(devicePixelRatio, devicePixelRatio);
                priceCtx.clearRect(0, 0, w, h);

                const allVisibleData = [...prices, ...slicedData.fastEma.filter(v=>v), ...slicedData.slowEma.filter(v=>v)];
                const minY = Math.min(...allVisibleData), maxY = Math.max(...allVisibleData);
                const margin = { top: 20, right: 50, bottom: 40, left: 50 };
                const chartW = w - margin.left - margin.right, chartH = h - margin.top - margin.bottom;

                const mapX = (i) => margin.left + (prices.length > 1 ? (i / (prices.length - 1)) * chartW : chartW / 2);
                const mapY = (v) => h - margin.bottom - ((v - minY) / (maxY - minY)) * chartH;
                
                priceCtx.font = "12px sans-serif";
                priceCtx.textAlign = 'right';
                priceCtx.fillStyle = '#a0a0a0';
                for (let i = 0; i <= 5; i++) {
                    const val = minY + (i / 5) * (maxY - minY);
                    const y = mapY(val);
                    priceCtx.beginPath(); priceCtx.strokeStyle = '#444'; priceCtx.lineWidth = 0.5;
                    priceCtx.moveTo(margin.left, y); priceCtx.lineTo(w - margin.right, y);
                    priceCtx.stroke();
                    priceCtx.fillText(val.toFixed(2), margin.left - 8, y + 4);
                }
                const xTickStep = Math.max(1, Math.floor(prices.length / Math.floor(chartW / 100)));
                for (let i = 0; i < prices.length; i += xTickStep) {
                    priceCtx.textAlign = 'center';
                    priceCtx.fillText(dates[i], mapX(i), h - margin.bottom + 20);
                }

                drawLine(priceCtx, prices, mapX, mapY, '#a0a0a0', 1.5);
                drawLine(priceCtx, slicedData.fastEma, mapX, mapY, '#3273dc');
                drawLine(priceCtx, slicedData.slowEma, mapX, mapY, '#23d160');

                const legX = margin.left + 10, legY = margin.top + 10, sp = 18;
                priceCtx.font = "14px sans-serif";
                priceCtx.textAlign = 'left';
                priceCtx.fillStyle = '#a0a0a0'; priceCtx.fillText('Price', legX, legY);
                priceCtx.fillStyle = '#3273dc'; priceCtx.fillText(`Fast EMA (${fastPeriod})`, legX, legY + sp);
                priceCtx.fillStyle = '#23d160'; priceCtx.fillText(`Slow EMA (${slowPeriod})`, legX, legY + sp * 2);
            }

            function drawMacdChart(dates, prices, slicedData) {
                const { macdLine, signalLine, histogram } = slicedData;
                const container = macdCanvas.parentElement;
                const w = container.clientWidth, h = container.clientHeight;
                if (w <= 0 || h <= 0) return;
                
                macdCanvas.width = w * devicePixelRatio;
                macdCanvas.height = h * devicePixelRatio;
                macdCtx.scale(devicePixelRatio, devicePixelRatio);
                macdCtx.clearRect(0, 0, w, h);

                const allVisibleData = [...macdLine.filter(v=>v), ...signalLine.filter(v=>v), ...histogram.filter(v=>v)];
                if (allVisibleData.length === 0) return;
                const minY = Math.min(...allVisibleData), maxY = Math.max(...allVisibleData);
                const margin = { top: 20, right: 50, bottom: 40, left: 50 };
                const chartW = w - margin.left - margin.right, chartH = h - margin.top - margin.bottom;

                const mapX = (i) => margin.left + (prices.length > 1 ? (i / (prices.length - 1)) * chartW : chartW / 2);
                const mapY = (v) => h - margin.bottom - ((v - minY) / (maxY - minY)) * chartH;

                const yZero = mapY(0);
                macdCtx.beginPath(); macdCtx.strokeStyle = '#a0a0a0'; macdCtx.lineWidth = 1;
                macdCtx.moveTo(margin.left, yZero); macdCtx.lineTo(w - margin.right, yZero);
                macdCtx.stroke();

                const barW = Math.max(1, chartW / prices.length * 0.8);
                for(let i = 0; i < histogram.length; i++) {
                    if(histogram[i] !== null) {
                        const x = mapX(i) - barW / 2;
                        const y = mapY(histogram[i]);
                        macdCtx.fillStyle = histogram[i] > 0 ? 'rgba(35, 209, 96, 0.7)' : 'rgba(255, 56, 96, 0.7)';
                        macdCtx.fillRect(x, y, barW, yZero - y);
                    }
                }

                drawLine(macdCtx, macdLine, mapX, mapY, '#007bff');
                drawLine(macdCtx, signalLine, mapX, mapY, '#fd7e14');

                const legX = margin.left + 10, legY = margin.top + 10, sp = 18;
                macdCtx.font = "14px sans-serif";
                macdCtx.textAlign = 'left';
                macdCtx.fillStyle = '#007bff'; macdCtx.fillText('MACD Line', legX, legY);
                macdCtx.fillStyle = '#fd7e14'; macdCtx.fillText('Signal Line', legX, legY + sp);
            }
        })();
    </script>
</body>
</html>